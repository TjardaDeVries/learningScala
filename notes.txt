
https://www.manning.com/books/functional-programming-in-scala

scala interpreter		scala
scala compiler			scalac

expression				program text that can be evaluated/run by Scala,
						main component of a Scala program,
						exists at compile time,
						evaluates to/has a value,
						has a type (determined a compile time), 
value					information stored in memory
						exists at runtime
						is an object
type					an expression has a type, a value does not
						exists at compile time, not at runtime	

identifier: type = value , eg. res0: String = HELLO WORLD!

statements				do not have a value / result ??? eg. println(<arg>)
commands				:<command>
:paste					enter multiple lines; paste contents of file to console 
:type					print type of expression, don't evaluate

Trait

compile time			1. syntactically correct, 2. type checking
runtime
compile time and runtime errors

type erasure			When a program type checks, Scala guarantees that all values are used consistently and thus it does not need to record type information in a value�s
						representation. This process of removing type information is called type erasure
type system

Infix Operator Notation	Any Scala expression written a.b(c) can also be written a b c.
literal expression		evaluates to a fixed value that stands 'for itself'

TYPES:
=====
Number					Int (42), Double (42.0), Float (42.0f), Long (42L)     (,Short, Byte)
Boolean					true, false
Char					'a'
String					"abc"
Null 					null
Unit					scala equivalent of void, ()
Any                     grand supertype of all Scala types
Nothing                 throw-expressions
Null, Nothing           These special types are subtypes of everything else

declaration				kind of SCala program, binding names to values. 
						Declarations are different to expressions. They do not evaluate to a value and do not have a type.
fields					fields refer to values stored within an object
methods					methods refer to computations that produce values

val vs. var             immutable vs. mutable fields

METHOD FOR CREATING METHODS
===========================
1. Identify the Input and Output
2. Prepare Test Cases
3. Write the Declaration
4. Run the Code
5. Write the Body
5.1 Consider the Result Type
5.2 Consider the Input Type
6. Run the Code, Again

compound expressions:
conditionals
blocks                  The type and value of a block is that of the last expression in the block.

expressions             evaluate to values
declarations            give names to values

object					grouping of methods and fields
                        a value
class                   template for an object
                        allows us to create many objects with the same Type
                        not a value
                        binds a name to ...
                        'lives' in a namespace

substitution model

Keyword Parameters      are robust to changes in the number and order of parameters
method chaining         new Counter(10).inc.dec.inc.inc.count
method overloading

functions               objects representing computations
types                   the way we properly abstract across values
companion object        To define a companion object for a class, in the same file as the class, define an object with the same name.
                        Companion objects replace Java’s static methods.
Scala has two namespaces: the namespace of values and the namespace of types

eq                      test for reference identity
==, equals              test if  all field values are equal?

CASE CLASSES
============
Features of a case class:
1. A field for each constructor argument
2. A default toString method
3. Sensible equals, and hashCode methods that operate on the field values in the object
4. A copy method that creates a new object with the same field values as the current one

Features of a case class companion object
1. contains an apply method with the same arguments as the class constructor
2. contains code to implement an extractor pattern for use in pattern matching

case object             use instead of case class with no constructor arguments
                        defines a class and an object, and makes the object an instance (actually the only instance) of the class
                        With a case object we still get all of the functionality defined for case classes


PATTERN MATCHING
================
A pattern can be one of:
1. a name, binding any value to that name;
2. an underscore, matching any value and ignoring it;
3. a literal, matching the value the literal denotes; or
4. a constructor-style pattern for a case class.

algebraic datatype      a description of data
structural recursion    mechanically write code that transforms an algebraic datatype

Traits                  are templates for creating classes, in the same way that classes are templates for creating objects
                        traits allow us to express that multiple classes share a common super-type

It is good practice to never define vals in a trait, but rather to use def.

Sealed trait            When we mark a trait as sealed we must define all of its subtypes in the same file.
                        If all the subtypes of a trait are known, seal the trait
                        Consider making subtypes final if there is no case for extending them
                        Remember subtypes must be defined in the same file as a sealed trait.

Pattern:

sealed trait TraitName { ... }
final case class Name(...) extends TraitName

The main advantages of this pattern are:
1. the compiler will warn if we miss a case in pattern matching; and
2. we can control extension points of sealed traits and thus make stronger guarantees about the behaviour of subtypes.

s"...... ${varname} ....."    is called 'string interpolation'


ALGEBRAIC DATA TYPES
====================
algebraic data types    sum and product types,
                        The sum and product type patterns tell us how to combine data to make bigger data
Product Type Pattern    “A has a B and C”
                        “has-a and”
                        implememtations:
                            case class A(b: B, c: C)
                            trait A {def b: B; def c: C}
Sum Type Pattern        "A is a B or C" (and nothing else!)
                        "is-a or"
(implememtation:

sealed trait A
final case class B() extends A
final case class C() extends A

)

Algebraic Data Types    An algebraic data type is any data that uses the above two patterns.

Patterns:               implementation
1. is-a or              => sum type pattern
2. is-a and             => trait that extends multiple other traits
3. has-a or             => combination of sum and product type pattern
4. has-a and            => product type pattern



STRUCTURAL RECURSION
====================
structural recursion    pattern for using algebraic data types, 2 variants:
                        polymorphism
                        pattern matching

Structural recursion says that if we have an A as defined before (case class A(b: B, c: C)),
we must break it into its constituent B and C that we then combine in some way to get closer to our desired answer.

Structural recursion is essentially the process of breaking down data into smaller pieces.

Just as we have two patterns for building algebraic data types, we will have two patterns for decomposing them using
structural recursion. We will actually have two variants of each pattern, one using polymorphism, which is the typical
object-oriented style, and one using pattern matching, which is typical functional style.

Polymorphism
Polymorphic dispatch, or just polymorphism for short, is a fundamental object-oriented technique. If we define a
method in a trait, and have different implementations in classes extending that trait, when we call that method the
implementation on the actual concrete instance will be used


STRUCTURAL RECURSION PATTERNS:

1. POLYMORPHISM:


1.1 The Product Type Polymorphism Pattern
=========================================
case class A(b: B, c: C) {
  def f: F = ???
}

1.2 The Sum Type Polymorphism Pattern
=====================================
sealed trait A {
  def f: F
}
final case class B() extends A {
  def f: F =
    ???
}
final case class C() extends A {
  def f: F =
    ???
}


2 PATTERN MATCHING:

2.1 The Product Type Pattern Matching Pattern
=============================================
def f(a: A): F =
  a match {
    case A(b, c) => ???
  }

2.2 The Sum Type Pattern Matching Pattern
=========================================
def f(a: A): F =
  a match {
    case B() => ???
    case C() => ???
  }



The general rule is: if a method only depends on other fields and methods in a class it is a good candidate to be
implemented inside the class. If the method depends on other data (for example, if we needed a Cook to make dinner)
consider implementing is using pattern matching outside of the classes in question. If we want to have more than one
implementation we should use pattern matching and implement it outside the classes.

tail call       A tail call is a method call where the caller immediately returns the value

def method1: Int =
  1

def tailCall: Int =
  method1

def notATailCall: Int =
  method1 + 2










